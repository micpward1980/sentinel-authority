"""
SENTINEL AUTHORITY — Continuous Surveillance Engine
====================================================
Post-certification enforcement layer. Watches heartbeats and telemetry
from certified ENVELO Interlocks and automatically:

  1. Computes real-time conformance scores (0-100)
  2. Suspends certificates when agents go dark
  3. Triggers alerts on violation threshold breaches
  4. Maintains full audit trail of enforcement actions

Drop into: backend/app/surveillance.py
Wire up in main.py with: from app.surveillance import start_surveillance
"""

import asyncio
import logging
from datetime import datetime, timezone, timedelta
from typing import Dict, Optional, List
from dataclasses import dataclass, field
from enum import Enum

from sqlalchemy import select, update, and_
from sqlalchemy.ext.asyncio import AsyncSession

log = logging.getLogger("sentinel.surveillance")


# ── Configuration ─────────────────────────────────────────────

class SurveillanceConfig:
    """Tunable thresholds for the surveillance engine."""

    # Heartbeat monitoring
    HEARTBEAT_STALE_SECONDS: int = 120        # 2 min — mark session "stale"
    HEARTBEAT_OFFLINE_SECONDS: int = 300       # 5 min — mark session "offline"
    HEARTBEAT_SUSPEND_SECONDS: int = 900       # 15 min — auto-suspend certificate

    # Conformance scoring
    SCORE_WINDOW_SECONDS: int = 3600           # 1-hour rolling window
    SCORE_MIN_SAMPLES: int = 50                # minimum actions before scoring

    # Violation thresholds
    VIOLATION_WARN_RATE: float = 0.02          # 2% block rate → WARN alert
    VIOLATION_CRITICAL_RATE: float = 0.05      # 5% block rate → CRITICAL alert
    VIOLATION_SUSPEND_RATE: float = 0.10       # 10% block rate → auto-suspend

    # Scan intervals
    SCAN_INTERVAL_SECONDS: int = 30            # how often the engine runs
    SCORE_RECALC_SECONDS: int = 60             # how often scores refresh

    # Grace period after certification
    GRACE_PERIOD_SECONDS: int = 300            # 5 min grace before enforcement kicks in


# ── Data structures ───────────────────────────────────────────

class AlertSeverity(str, Enum):
    INFO = "info"
    WARN = "warn"
    CRITICAL = "critical"
    SUSPENSION = "suspension"
    REVOCATION = "revocation"


class AlertType(str, Enum):
    HEARTBEAT_STALE = "heartbeat_stale"
    HEARTBEAT_OFFLINE = "heartbeat_offline"
    HEARTBEAT_SUSPEND = "heartbeat_suspend"
    VIOLATION_WARN = "violation_warn"
    VIOLATION_CRITICAL = "violation_critical"
    VIOLATION_SUSPEND = "violation_suspend"
    AGENT_RECONNECT = "agent_reconnect"
    SCORE_DEGRADED = "score_degraded"
    CERTIFICATE_SUSPENDED = "certificate_suspended"
    CERTIFICATE_REINSTATED = "certificate_reinstated"


@dataclass
class ConformanceScore:
    """Real-time conformance metric for a certified system."""
    certificate_id: str
    session_id: str
    score: float                    # 0-100
    pass_count: int = 0
    block_count: int = 0
    total_actions: int = 0
    block_rate: float = 0.0
    window_start: Optional[datetime] = None
    window_end: Optional[datetime] = None
    last_heartbeat: Optional[datetime] = None
    status: str = "unknown"         # healthy | degraded | critical | offline | suspended
    updated_at: Optional[datetime] = None

    def to_dict(self) -> dict:
        return {
            "certificate_id": self.certificate_id,
            "session_id": self.session_id,
            "score": round(self.score, 1),
            "pass_count": self.pass_count,
            "block_count": self.block_count,
            "total_actions": self.total_actions,
            "block_rate": round(self.block_rate, 4),
            "window_start": self.window_start.isoformat() if self.window_start else None,
            "window_end": self.window_end.isoformat() if self.window_end else None,
            "last_heartbeat": self.last_heartbeat.isoformat() if self.last_heartbeat else None,
            "status": self.status,
            "updated_at": self.updated_at.isoformat() if self.updated_at else None,
        }


@dataclass
class SurveillanceAlert:
    """Enforcement event generated by the surveillance engine."""
    id: str
    alert_type: AlertType
    severity: AlertSeverity
    certificate_id: str
    session_id: Optional[str]
    message: str
    details: dict = field(default_factory=dict)
    created_at: datetime = field(default_factory=lambda: datetime.now(timezone.utc))
    acknowledged: bool = False
    acknowledged_at: Optional[datetime] = None
    acknowledged_by: Optional[str] = None

    def to_dict(self) -> dict:
        return {
            "id": self.id,
            "alert_type": self.alert_type.value,
            "severity": self.severity.value,
            "certificate_id": self.certificate_id,
            "session_id": self.session_id,
            "message": self.message,
            "details": self.details,
            "created_at": self.created_at.isoformat(),
            "acknowledged": self.acknowledged,
            "acknowledged_at": self.acknowledged_at.isoformat() if self.acknowledged_at else None,
            "acknowledged_by": self.acknowledged_by,
        }


# ── In-memory state (backed by DB on write) ──────────────────

class SurveillanceState:
    _engine_started_at = None

    """
    Live state tracking for all monitored sessions.
    Kept in memory for speed, persisted to DB on state changes.
    """

    def __init__(self):
        self.scores: Dict[str, ConformanceScore] = {}       # session_id → score
        self.alerts: List[SurveillanceAlert] = []            # all alerts (recent)
        self.last_heartbeats: Dict[str, datetime] = {}       # session_id → last seen
        self.session_cert_map: Dict[str, str] = {}           # session_id → cert number
        self.suspended_certs: set = set()                    # cert IDs currently suspended by engine
        self._alert_counter: int = 0
        self._dedup_window: Dict[str, datetime] = {}         # alert dedup: key → last fired

    def record_heartbeat(self, session_id: str, certificate_id: str, stats: dict):
        """Called by the heartbeat endpoint to feed the engine."""
        now = datetime.now(timezone.utc)
        self.last_heartbeats[session_id] = now
        self.session_cert_map[session_id] = certificate_id

        # Update or create score
        if session_id not in self.scores:
            self.scores[session_id] = ConformanceScore(
                certificate_id=certificate_id,
                session_id=session_id,
                score=100.0,
                status="healthy",
            )

        score = self.scores[session_id]
        score.last_heartbeat = now
        score.updated_at = now

        # Update stats from heartbeat
        pass_count = stats.get("pass", stats.get("pass_count", 0))
        block_count = stats.get("block", stats.get("block_count", 0))
        score.pass_count = pass_count
        score.block_count = block_count
        score.total_actions = pass_count + block_count

        # If agent reconnects after being offline, fire reconnect alert
        if certificate_id in self.suspended_certs:
            # Don't auto-reinstate — that requires manual review
            self._fire_alert(
                AlertType.AGENT_RECONNECT,
                AlertSeverity.INFO,
                certificate_id,
                session_id,
                f"Interlock reconnected for {certificate_id} (certificate still suspended — manual review required)",
            )

    def record_telemetry(self, session_id: str, certificate_id: str, pass_count: int, block_count: int):
        """Called by the telemetry endpoint to update running totals."""
        if session_id in self.scores:
            score = self.scores[session_id]
            score.pass_count = pass_count
            score.block_count = block_count
            score.total_actions = pass_count + block_count
            score.updated_at = datetime.now(timezone.utc)

    def get_score(self, session_id: str) -> Optional[dict]:
        if session_id in self.scores:
            return self.scores[session_id].to_dict()
        return None

    def get_all_scores(self) -> List[dict]:
        return [s.to_dict() for s in self.scores.values()]

    def get_alerts(self, limit: int = 50, severity: Optional[str] = None,
                   certificate_id: Optional[str] = None) -> List[dict]:
        filtered = self.alerts
        if severity:
            filtered = [a for a in filtered if a.severity.value == severity]
        if certificate_id:
            filtered = [a for a in filtered if a.certificate_id == certificate_id]
        return [a.to_dict() for a in filtered[-limit:]]

    def acknowledge_alert(self, alert_id: str, acknowledged_by: str = "admin") -> bool:
        for alert in self.alerts:
            if alert.id == alert_id:
                alert.acknowledged = True
                alert.acknowledged_at = datetime.now(timezone.utc)
                alert.acknowledged_by = acknowledged_by
                # Persist to DB
                try:
                    import asyncio as _aio
                    async def _persist_ack():
                        from app.core.database import AsyncSessionLocal
                        from sqlalchemy import text as raw_t
                        async with AsyncSessionLocal() as db:
                            await db.execute(raw_t(
                                "UPDATE surveillance_alerts SET acknowledged=TRUE, acknowledged_at=:aat, acknowledged_by=:aby WHERE alert_id=:aid"
                            ), {"aat": alert.acknowledged_at, "aby": acknowledged_by, "aid": alert_id})
                            await db.commit()
                    loop = _aio.get_event_loop()
                    if loop.is_running():
                        _aio.ensure_future(_persist_ack())
                except Exception:
                    pass
                return True
        return False


    async def persist_alert_to_db(self, alert: 'SurveillanceAlert'):
        """Write alert to DB for persistence across restarts."""
        try:
            from app.core.database import AsyncSessionLocal
            from sqlalchemy import text as raw_t
            async with AsyncSessionLocal() as db:
                await db.execute(raw_t(
                    "INSERT INTO surveillance_alerts (alert_id, alert_type, severity, certificate_id, session_id, message, details, created_at, acknowledged) "
                    "VALUES (:aid, :atype, :sev, :cert, :sess, :msg, :det, :cat, :ack) "
                    "ON CONFLICT (alert_id) DO NOTHING"
                ), {
                    "aid": alert.id, "atype": alert.alert_type.value, "sev": alert.severity.value,
                    "cert": alert.certificate_id, "sess": alert.session_id, "msg": alert.message,
                    "det": __import__('json').dumps(alert.details), "cat": alert.created_at.replace(tzinfo=None), "ack": False,
                })
                await db.commit()
        except Exception as e:
            log.warning(f"[SURVEILLANCE] Alert DB persist failed (non-fatal): {e}")

    def _fire_alert(self, alert_type: AlertType, severity: AlertSeverity,
                    certificate_id: str, session_id: Optional[str], message: str,
                    details: dict = None, dedup_minutes: int = 5):
        """Fire an alert with dedup protection."""
        dedup_key = f"{alert_type.value}:{certificate_id}:{session_id or 'none'}"
        now = datetime.now(timezone.utc)

        if dedup_key in self._dedup_window:
            if (now - self._dedup_window[dedup_key]).total_seconds() < dedup_minutes * 60:
                return  # suppress duplicate

        self._dedup_window[dedup_key] = now
        self._alert_counter += 1

        alert = SurveillanceAlert(
            id=f"SA-ALERT-{self._alert_counter:06d}",
            alert_type=alert_type,
            severity=severity,
            certificate_id=certificate_id,
            session_id=session_id,
            message=message,
            details=details or {},
        )
        self.alerts.append(alert)
        log.warning(f"[SURVEILLANCE] {severity.value.upper()}: {message}")

        # Persist to DB
        import asyncio as _aio
        try:
            loop = _aio.get_event_loop()
            if loop.is_running():
                _aio.ensure_future(self.persist_alert_to_db(alert))
        except Exception:
            pass

        # Trim old alerts (keep last 500)
        if len(self.alerts) > 500:
            self.alerts = self.alerts[-500:]


# ── Global singleton ──────────────────────────────────────────

_state = SurveillanceState()
_config = SurveillanceConfig()


def get_surveillance_state() -> SurveillanceState:
    return _state


def get_surveillance_config() -> SurveillanceConfig:
    return _config


# ── Core scoring algorithm ────────────────────────────────────

def compute_conformance_score(pass_count: int, block_count: int,
                               last_heartbeat: Optional[datetime],
                               config: SurveillanceConfig = None) -> tuple:
    """
    Compute conformance score (0-100) and status.

    Score formula:
      base_score = (pass_count / total_actions) * 100
      heartbeat_penalty = based on staleness
      final_score = base_score - heartbeat_penalty

    Status levels:
      100-95  → healthy
      94-80   → degraded
      79-50   → critical
      < 50    → failing
      offline → offline (heartbeat lost)
    """
    if config is None:
        config = _config

    now = datetime.now(timezone.utc)
    total = pass_count + block_count

    # Not enough data yet
    if total < config.SCORE_MIN_SAMPLES:
        return 100.0, "initializing"

    # Base score from pass rate
    block_rate = block_count / total if total > 0 else 0
    base_score = ((total - block_count) / total) * 100

    # Heartbeat freshness penalty
    heartbeat_penalty = 0.0
    if last_heartbeat:
        staleness = (now - last_heartbeat).total_seconds()
        if staleness > config.HEARTBEAT_OFFLINE_SECONDS:
            heartbeat_penalty = 30.0   # heavy penalty — agent is offline
        elif staleness > config.HEARTBEAT_STALE_SECONDS:
            heartbeat_penalty = 10.0   # moderate — agent is stale

    final_score = max(0.0, min(100.0, base_score - heartbeat_penalty))

    # Determine status
    if last_heartbeat:
        staleness = (now - last_heartbeat).total_seconds()
        if staleness > config.HEARTBEAT_OFFLINE_SECONDS:
            status = "offline"
        elif staleness > config.HEARTBEAT_STALE_SECONDS:
            status = "stale"
        elif final_score >= 95:
            status = "healthy"
        elif final_score >= 80:
            status = "degraded"
        elif final_score >= 50:
            status = "critical"
        else:
            status = "failing"
    else:
        status = "unknown"

    return final_score, status


# ── Background scan loop ─────────────────────────────────────

async def _surveillance_scan(get_db_session):
    """
    Single scan pass. Runs every SCAN_INTERVAL_SECONDS.
    Checks all tracked sessions for:
      - Heartbeat staleness → alerts + suspension
      - Violation rates → alerts + suspension
      - Score recalculation
    """
    now = datetime.now(timezone.utc)

    for session_id, score in list(_state.scores.items()):
        cert_id = score.certificate_id
        last_hb = _state.last_heartbeats.get(session_id)

        # Skip if cert already manually revoked (not our business)
        # We only manage auto-suspensions

        # ── 1. Recalculate conformance score ──
        new_score, new_status = compute_conformance_score(
            score.pass_count, score.block_count, last_hb
        )
        score.score = new_score
        score.status = new_status
        score.block_rate = score.block_count / score.total_actions if score.total_actions > 0 else 0
        score.window_end = now
        score.updated_at = now

        # ── 2. Heartbeat monitoring ──
        if last_hb:
            staleness = (now - last_hb).total_seconds()

            if staleness > _config.HEARTBEAT_SUSPEND_SECONDS:
                # AUTO-SUSPEND: Interlock has been dark too long
                if cert_id not in _state.suspended_certs:
                    _state.suspended_certs.add(cert_id)
                    _state._fire_alert(
                        AlertType.HEARTBEAT_SUSPEND,
                        AlertSeverity.SUSPENSION,
                        cert_id, session_id,
                        f"Certificate {cert_id} AUTO-SUSPENDED: no heartbeat for {int(staleness)}s",
                        details={"staleness_seconds": int(staleness), "action": "auto_suspend"},
                        dedup_minutes=30,
                    )
                    # Persist to DB
                    await _suspend_certificate_in_db(cert_id, get_db_session,
                        reason=f"Surveillance auto-suspend: no heartbeat for {int(staleness)}s")
                    score.status = "suspended"

            elif staleness > _config.HEARTBEAT_OFFLINE_SECONDS:
                _state._fire_alert(
                    AlertType.HEARTBEAT_OFFLINE,
                    AlertSeverity.CRITICAL,
                    cert_id, session_id,
                    f"Interlock offline for {cert_id}: no heartbeat for {int(staleness)}s",
                    details={"staleness_seconds": int(staleness)},
                    dedup_minutes=5,
                )

            elif staleness > _config.HEARTBEAT_STALE_SECONDS:
                _state._fire_alert(
                    AlertType.HEARTBEAT_STALE,
                    AlertSeverity.WARN,
                    cert_id, session_id,
                    f"Interlock stale for {cert_id}: no heartbeat for {int(staleness)}s",
                    details={"staleness_seconds": int(staleness)},
                    dedup_minutes=5,
                )

        # ── 3. Violation rate monitoring ──
        if score.total_actions >= _config.SCORE_MIN_SAMPLES:
            block_rate = score.block_rate

            if block_rate >= _config.VIOLATION_SUSPEND_RATE:
                # AUTO-SUSPEND: Too many violations
                if cert_id not in _state.suspended_certs:
                    _state.suspended_certs.add(cert_id)
                    _state._fire_alert(
                        AlertType.VIOLATION_SUSPEND,
                        AlertSeverity.SUSPENSION,
                        cert_id, session_id,
                        f"Certificate {cert_id} AUTO-SUSPENDED: block rate {block_rate:.1%} exceeds {_config.VIOLATION_SUSPEND_RATE:.0%} threshold",
                        details={"block_rate": block_rate, "threshold": _config.VIOLATION_SUSPEND_RATE, "action": "auto_suspend"},
                        dedup_minutes=30,
                    )
                    await _suspend_certificate_in_db(cert_id, get_db_session,
                        reason=f"Surveillance auto-suspend: block rate {block_rate:.1%}")
                    score.status = "suspended"

            elif block_rate >= _config.VIOLATION_CRITICAL_RATE:
                _state._fire_alert(
                    AlertType.VIOLATION_CRITICAL,
                    AlertSeverity.CRITICAL,
                    cert_id, session_id,
                    f"Critical violation rate for {cert_id}: {block_rate:.1%} (threshold: {_config.VIOLATION_CRITICAL_RATE:.0%})",
                    details={"block_rate": block_rate, "threshold": _config.VIOLATION_CRITICAL_RATE},
                )

            elif block_rate >= _config.VIOLATION_WARN_RATE:
                _state._fire_alert(
                    AlertType.VIOLATION_WARN,
                    AlertSeverity.WARN,
                    cert_id, session_id,
                    f"Elevated violation rate for {cert_id}: {block_rate:.1%} (threshold: {_config.VIOLATION_WARN_RATE:.0%})",
                    details={"block_rate": block_rate, "threshold": _config.VIOLATION_WARN_RATE},
                )

        # ── 4. Score degradation alert ──
        if new_status == "degraded" and score.total_actions >= _config.SCORE_MIN_SAMPLES:
            _state._fire_alert(
                AlertType.SCORE_DEGRADED,
                AlertSeverity.WARN,
                cert_id, session_id,
                f"Conformance score degraded for {cert_id}: {new_score:.1f}/100",
                details={"score": new_score, "block_rate": score.block_rate},
                dedup_minutes=15,
            )


async def _suspend_certificate_in_db(certificate_id: str, get_db_session, reason: str = ""):
    """Persist certificate suspension to database."""
    try:
        async with get_db_session() as db:
            # Import here to avoid circular imports
            from app.models.models import Certificate

            result = await db.execute(
                select(Certificate).where(Certificate.certificate_number == certificate_id)
            )
            cert = result.scalar_one_or_none()
            if cert and cert.status not in ("suspended", "revoked"):
                cert.status = "suspended"
                cert.suspended_at = datetime.now(timezone.utc)
                cert.suspension_reason = reason
                cert.suspended_by = "surveillance_engine"
                await db.commit()
                log.warning(f"[SURVEILLANCE] DB: Certificate {certificate_id} suspended — {reason}")
                # Audit trail
                try:
                    from app.services.audit_service import write_audit_log
                    await write_audit_log(db, action="certificate_auto_suspended",
                        resource_type="certificate", user_email="surveillance_engine",
                        details={"certificate_id": certificate_id, "reason": reason})
                except Exception:
                    pass
    except Exception as e:
        log.error(f"[SURVEILLANCE] Failed to suspend {certificate_id} in DB: {e}")


async def _reinstate_certificate_in_db(certificate_id: str, get_db_session, reason: str = ""):
    """Reinstate a suspended certificate (admin action, not automatic)."""
    try:
        async with get_db_session() as db:
            from app.models.models import Certificate

            result = await db.execute(
                select(Certificate).where(Certificate.certificate_number == certificate_id)
            )
            cert = result.scalar_one_or_none()
            if cert and cert.status == "suspended":
                cert.status = "active"
                cert.reinstated_at = datetime.now(timezone.utc)
                cert.reinstatement_reason = reason
                await db.commit()
                log.warning(f"[SURVEILLANCE] DB: Certificate {certificate_id} reinstated — {reason}")

                _state.suspended_certs.discard(certificate_id)
                _state._fire_alert(
                    AlertType.CERTIFICATE_REINSTATED,
                    AlertSeverity.INFO,
                    certificate_id, None,
                    f"Certificate {certificate_id} reinstated: {reason}",
                )
                return True
    except Exception as e:
        log.error(f"[SURVEILLANCE] Failed to reinstate {certificate_id}: {e}")
    return False


# ── Engine startup ────────────────────────────────────────────

async def _surveillance_loop(get_db_session):
    _state._engine_started_at = datetime.now(timezone.utc)
    """Main loop — runs continuously in background."""
    log.info("[SURVEILLANCE] Engine started — scanning every %ds", _config.SCAN_INTERVAL_SECONDS)
    while True:
        try:
            await _surveillance_scan(get_db_session)
        except Exception as e:
            log.error(f"[SURVEILLANCE] Scan error: {e}")
        await asyncio.sleep(_config.SCAN_INTERVAL_SECONDS)


_task: Optional[asyncio.Task] = None


def start_surveillance(get_db_session):
    """
    Call from FastAPI startup event.

    Usage in main.py:
        from app.surveillance import start_surveillance
        from app.database import get_db_session  # your async session factory

        @app.on_event("startup")
        async def startup():
            start_surveillance(get_db_session)
    """
    global _task
    if _task is None or _task.done():
        _task = asyncio.create_task(_surveillance_loop(get_db_session))
        log.info("[SURVEILLANCE] Background task created")
    return _task
